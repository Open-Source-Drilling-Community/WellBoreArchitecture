@inject ILogger<WellBoreArchitectureMain> logger
@inject ISnackbar Snackbar

@if (WellBoreArchitecture != null)
{
    <MudText Typo="Typo.h6"> <b>Wellbore Architecture Editor</b></MudText>
    <MudSpacer />
    <MudToolBar>
        <MudSpacer />
        <MudButton IconColor="@Color.Primary" StartIcon="@Icons.Material.Filled.Save" Size="@Size.Medium" OnClick="@SaveWellBoreArchitecture">Save</MudButton>
        <MudButton IconColor="@Color.Primary" StartIcon="@Icons.Material.Filled.Cancel" Size="@Size.Medium" OnClick="@CloseWellBoreArchitecture">Cancel</MudButton>
    </MudToolBar>
    <MudPaper Class="py-2 px-4">
        <MudGrid Class="my-2">
            <InputHeader xs="3" Text="Creation date" />
            <InputHeader xs="3" Text="Last modification date" />
        </MudGrid>
        <MudGrid Class="my-2">
            <MudItem xs="3">
                <MudText Typo="Typo.body1">@WellBoreArchitecture.CreationDate</MudText>
            </MudItem>
            <MudItem xs="3">
                <MudText Typo="Typo.body1">@WellBoreArchitecture.LastModificationDate</MudText>
            </MudItem>
        </MudGrid>

        <MudGrid Class="my-2">
            <InputHeader xs="2" Text="Name" />
            <InputHeader xs="2" Text="Description" />
            <InputHeader xs="2" Text="Field" />
            <InputHeader xs="2" Text="Cluster" />
            <InputHeader xs="2" Text="Well" />
            <InputHeader xs="2" Text="Wellbore" />
        </MudGrid>

        <MudGrid Class="my-2">
            <MudItem xs="2">
                <MudTextField @bind-Value="@WellBoreArchitecture.Name" Variant="Variant.Text"></MudTextField>
            </MudItem>
            <MudItem xs="2">
                <MudTextField @bind-Value="@WellBoreArchitecture.Description" Variant="Variant.Text"></MudTextField>
            </MudItem>
            @if (Fields != null)
            {
                <MudItem xs="2">
                    <MudSelect Label="Field" @bind-Value="@_selectedField" Dense="true" ToStringFunc="@(s => s?.Name)">
                        @foreach (var fieldKPV in Fields)
                        {
                            if (fieldKPV.Key != Guid.Empty && fieldKPV.Value != null && !string.IsNullOrEmpty(fieldKPV.Value.Name))
                            {
                                <MudSelectItem Value="@fieldKPV.Value">@fieldKPV.Value.Name</MudSelectItem>
                            }
                        }
                    </MudSelect>
                </MudItem>
            }
            else
            {
                <MudItem xs="2" />
            }
            @if (Clusters != null && _selectedField != null)
            {
                <MudItem xs="2">
                    <MudSelect Label="Cluster" @bind-Value="@_selectedCluster" Dense="true" ToStringFunc="@(s => s?.Name)">
                        @foreach (var clusterKVP in Clusters.Where(x => (x.Value != null && x.Value.FieldID != null && _selectedField != null && _selectedField.MetaInfo != null && _selectedField.MetaInfo.ID == x.Value.FieldID && !x.Value.IsSingleWell)))
                        {
                            <MudSelectItem Value="@clusterKVP.Value">@clusterKVP.Value.Name</MudSelectItem>
                        }
                    </MudSelect>
                </MudItem>
            }
            else
            {
                <MudItem xs="2" />
            }
            @if (Wells != null)
            {
                <MudItem xs="2">
                    <MudSelect Label="Well" @bind-Value="@_selectedWell" Dense="true" ToStringFunc="@(s => s?.Name)">
                        @foreach (var wellKVP in Wells.Where(x => (x.Value != null && ((x.Value.ClusterID != null && _selectedCluster != null && _selectedCluster.MetaInfo != null && _selectedCluster.MetaInfo.ID == x.Value.ClusterID && !x.Value.IsSingleWell) || (x.Value.IsSingleWell)))))
                        {
                            <MudSelectItem Value="@wellKVP.Value">@wellKVP.Value.Name</MudSelectItem>
                        }
                    </MudSelect>
                </MudItem>
            }
            else
            {
                <MudItem xs="2" />
            }
            @if (WellBores != null && _selectedWell != null)
            {
                <MudItem xs="2">
                    <MudSelect Label="Wellbore" @bind-Value="@_selectedWellBore" Dense="true" ToStringFunc="@(s => s?.Name)">
                        @foreach (var wellBoreKVP in WellBores.Where(x => (x.Value != null && x.Value.WellID != null && _selectedWell != null && _selectedWell.MetaInfo != null && _selectedWell.MetaInfo.ID == x.Value.WellID)))
                        {
                            <MudSelectItem Value="@wellBoreKVP.Value">@wellBoreKVP.Value.Name</MudSelectItem>
                        }
                    </MudSelect>
                </MudItem>
            }
            else
            {
                <MudItem xs="2" />
            }
        </MudGrid>
    </MudPaper>
    @if (WellBoreArchitecture.WellHead != null)
    {
        <WellHeadEditor Class="py-2 px-4 mt-4" WellHead="@WellBoreArchitecture.WellHead" />
    }
    @if (WellBoreArchitecture.FluidsAboveGroundLevel != null)
    {
        <FluidPropertiesMain Class="py-2 px-4 mt-4" WellBoreArchitectureFluids="@WellBoreArchitecture.FluidsAboveGroundLevel" />
    }
    @if (WellBoreArchitecture.SurfaceSections != null)
    {
        <SurfaceSectionMain Class="py-2 px-4 mt-4" SurfaceSections="@WellBoreArchitecture.SurfaceSections" />
    }
    @if (WellBoreArchitecture.CasingSections != null)
    {
        <CasingSectionMain Class="py-2 px-4 mt-4" CasingSections="@WellBoreArchitecture.CasingSections" />
    }
    <MudToolBar>
        <MudSpacer />
        <MudButton IconColor="@Color.Primary" StartIcon="@Icons.Material.Filled.Save" Size="@Size.Medium" OnClick="@SaveWellBoreArchitecture">Save</MudButton>
        <MudButton IconColor="@Color.Primary" StartIcon="@Icons.Material.Filled.Cancel" Size="@Size.Medium" OnClick="@CloseWellBoreArchitecture">Cancel</MudButton>
    </MudToolBar>
}

@code {
    [CascadingParameter]
    private MudUnitAndReferenceChoiceTag? Parent { get; set; }
    [Parameter]
    public WellBoreArchitecture? WellBoreArchitecture { get; set; } = null;
    [Parameter]
    public Dictionary<Guid, Field>? Fields { get; set; } = null;
    [Parameter]
    public Dictionary<Guid, Cluster>? Clusters { get; set; } = null;
    [Parameter]
    public Dictionary<Guid, Well>? Wells { get; set; } = null;
    [Parameter]
    public Dictionary<Guid, WellBore>? WellBores { get; set; } = null;
    [Parameter]
    public Action? OnUpdate { get; set; }

    private Field? _selectedField = null;
    private Cluster? _selectedCluster = null;
    private Well? _selectedWell = null;
    private WellBore? _selectedWellBore = null;

    double depth;
    GaussianDrillingProperty doubleToGaussian(double? val)
    {
        if (val == null) { val = 0.0; }

        GaussianDrillingProperty gaussValue = new GaussianDrillingProperty()
        {
            GaussianValue = new GaussianDistribution() { Mean = val }
        };
        return gaussValue;
    }
    protected override async Task OnInitializedAsync()
    {
        // Prepare local variables
        if (WellBoreArchitecture != null)
        {
            //Grab old values for well bore architecture
            if (WellBoreArchitecture.WellHead == null)
            {
                WellBoreArchitecture.WellHead = APIUtils.DefaultWellHead();
            }
            if (WellBoreArchitecture.FluidsAboveGroundLevel == null)
            {
                WellBoreArchitecture.FluidsAboveGroundLevel = APIUtils.DefaultFluidsAboveGroundLevel();
            }
            if (WellBoreArchitecture.SurfaceSections == null)
            {
                WellBoreArchitecture.SurfaceSections = APIUtils.DefaultSurfaceSections();
            }
            if (WellBoreArchitecture.CasingSections == null)
            {
                WellBoreArchitecture.CasingSections = APIUtils.DefaultCasingSections();
            }
            Guid? wbaWellBoreID = WellBoreArchitecture.WellBoreID;
            if (wbaWellBoreID != null && wbaWellBoreID != Guid.Empty)
            {
                WellBore wellBore = await APIUtils.ClientWellBore.GetWellBoreByIdAsync(wbaWellBoreID.Value);
                if (wellBore != null && wellBore.WellID != null && wellBore.WellID != Guid.Empty)
                {
                    _selectedWellBore = wellBore;
                    Well well = await APIUtils.ClientWell.GetWellByIdAsync(wellBore.WellID.Value);
                    if (well != null && well.ClusterID != null && well.ClusterID != Guid.Empty)
                    {
                        _selectedWell = well;
                        Cluster cluster = await APIUtils.ClientCluster.GetClusterByIdAsync(well.ClusterID.Value);
                        if (cluster != null && cluster.FieldID != null && cluster.FieldID != Guid.Empty)
                        {
                            if (cluster.ReferenceDepth != null && cluster.ReferenceDepth.GaussianValue != null && cluster.ReferenceDepth.GaussianValue.Mean != null)
                            {
                                DataUtils.UnitAndReferenceParameters.WellHeadDepthReferenceSource.WellHeadDepthReference = cluster.ReferenceDepth.GaussianValue.Mean;
                            }
                            // if (cluster.RotaryTableDepth != null && cluster.RotaryTableDepth.DiracDistributionValue != null && cluster.RotaryTableDepth.DiracDistributionValue.Value != null)
                            // {
                            //     DataUtils.UnitAndReferenceParameters.RotaryTableDepthReferenceSource.RotaryTableDepthReference = cluster.RotaryTableDepth.DiracDistributionValue.Value;
                            // }
                            if (cluster.GroundMudLineDepth != null && cluster.GroundMudLineDepth.GaussianValue != null && cluster.GroundMudLineDepth.GaussianValue.Mean != null)
                            {
                                DataUtils.UnitAndReferenceParameters.GroundMudLineDepthReferenceSource.GroundMudLineDepthReference = cluster.GroundMudLineDepth.GaussianValue.Mean;
                            }
                            if (cluster.TopWaterDepth != null && cluster.TopWaterDepth.GaussianValue != null && cluster.TopWaterDepth.GaussianValue.Mean != null)
                            {
                                DataUtils.UnitAndReferenceParameters.SeaWaterLevelDepthReferenceSource.SeaWaterLevelDepthReference = cluster.TopWaterDepth.GaussianValue.Mean;
                            }
                            if (!cluster.IsSingleWell)
                            {
                                _selectedCluster = cluster;
                            }
                            Field field = await APIUtils.ClientField.GetFieldByIdAsync(cluster.FieldID.Value);
                            if (field != null)
                            {
                                _selectedField = field;
                            }
                        }
                    }
                }
            }
        }
    }

    private async Task SaveWellBoreArchitecture()
    {
        try
        {
            if (WellBoreArchitecture != null)
            {
                DateTimeOffset modificationDate = DateTimeOffset.UtcNow;
                WellBoreArchitecture.WellBoreID = (_selectedWellBore != null && _selectedWellBore.MetaInfo != null && _selectedWellBore.MetaInfo.ID != Guid.Empty) ? _selectedWellBore.MetaInfo.ID : null;
                WellBoreArchitecture.LastModificationDate = modificationDate;
                await APIUtils.ClientWellBoreArchitecture.PutWellBoreArchitectureByIdAsync(WellBoreArchitecture.MetaInfo.ID, WellBoreArchitecture);
                logger.LogInformation("Wellbore Architecture updated successfully");
                Snackbar.Add("Wellbore Architecture updated successfully", Severity.Success);
            }
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Impossible to update Wellbore Architecture");
            Snackbar.Add("Impossible to update Wellbore Architecture", Severity.Warning);
        }
        OnUpdate?.Invoke();
    }
    private void CloseWellBoreArchitecture()
    {
        OnUpdate?.Invoke();
    }
}